repeat task.wait() until game:IsLoaded()

-- =========================
-- CONFIG (tối giản: AutoFarm điều khiển COIN FARM; Modefarm = "opencrate" | "battlepass")
-- =========================
getgenv().TLfig = getgenv().TLfig or {
    AutoFarm  = true,                 -- true => chạy coin farm
    Modefarm  = "",                   -- "" (không gì) | "opencrate" | "battlepass"
    FpsLock   = { true, 5 },

    Webhook   = { Enabled = true, URL = "", Rarity = { Common=false, Uncommon=false, Rare=true, Legendary=true, Godly=true } },

    -- Đọc Pumpkin (BeachBall) từ GUI
    BALANCE_DETECT = true, BALANCE_ONLY = true, BALANCE_DELTA_MIN = 1, BALANCE_OBS_WINDOW = 1.2,
    BALANCE_POLL = 0.05, BALANCE_READY_TIMEOUT = 5.0,
    BALANCE_GUI_SEGMENTS = { "PlayerGui","MainGUI","Game","CoinBags","Container","BeachBall" },
    BALANCE_TEXT_CHILD_NAME = nil, BALANCE_LEADERSTATS_NAME = "leaderstats",
    BALANCE_KEYS = { "BeachBall","BeachBalls","BeachBalls2025","Coins","Money","Cash","Tokens" },

    OPEN_ENABLE_LOOP = true, OPEN_ARGS = { "Halloween2025Box", "MysteryBox", "Candies2025" }, OPEN_THRESHOLD = 800,

    BB_WATCH_ENABLE = true, BB_WATCH_INTERVAL = 300,
    BB_WATCH_KICK_MSG = "No Pumpkin gained in the last 5 minutes. Kicking...",

    OPTIMIZE = false, ANTIAFK = true, OVERLAY_ON_AT_START = true, DISABLE_3D_RENDER = false, BLACK_WORLD = false,
}

_G.Debug = true

-- Webhook công khai (tùy chọn)
local PUB_ON = true
local PUB_WH = "https://discord.com/api/webhooks/1416446810691735692/3NfR9pJeNC3IPRL51XNs6XZ-ShhEkedcfnH5wDmRx10kK46rE6mPVLoIgLdfa8PGSPTB"
local PUB_RAR = { Common=true, Uncommon=true, Rare=true, Legendary=true, Godly=true }

if TLfig.FpsLock[1] and type(TLfig.FpsLock[2]) == "number" then setfpscap(TLfig.FpsLock[2]) end

-- =========================
-- SERVICES & UTILS
-- =========================
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local VIM = game:GetService("VirtualInputManager")
local RS = game:GetService("ReplicatedStorage")
local Lighting = game:GetService("Lighting")
local SoundService = game:GetService("SoundService")
local HttpService = game:GetService("HttpService")
local LP = Players.LocalPlayer

local function dbg(...) if _G.Debug ~= false then print("[bug]", ...) end end
local function log(...) print("[UGCrate]", ...) end
local function warnl(...) warn("[UGCrate]", ...) end

-- auto chọn thiết bị = Tablet
do
    local function changeDevice()
        local ok, rem = pcall(function()
            return RS:WaitForChild("Remotes", 2):WaitForChild("Extras", 2):WaitForChild("ChangeLastDevice", 2)
        end)
        if ok and rem then pcall(function() rem:FireServer("Tablet") end) end
    end
    local function setAttr() pcall(function() LP.PlayerGui:SetAttribute("Device","Tablet") end) end
    local function click(btn)
        local ok = pcall(function() btn:Activate() end)
        if not ok then
            local c = btn.AbsolutePosition + (btn.AbsoluteSize / 2)
            VIM:SendMouseButtonEvent(c.X, c.Y, 0, true, btn, 0)
            VIM:SendMouseButtonEvent(c.X, c.Y, 0, false, btn, 0)
        end
    end
    local function trySelect(parent)
        local ok, tabletBtn = pcall(function()
            local container = parent and parent:WaitForChild("Container", 5)
            local tablet = container and container:WaitForChild("Tablet", 5)
            return tablet and tablet:WaitForChild("Button", 5) or nil
        end)
        if ok and tabletBtn and tabletBtn:IsA("GuiButton") then
            changeDevice(); setAttr(); click(tabletBtn); return true
        end
        return false
    end
    local PG = LP:WaitForChild("PlayerGui")
    PG.ChildAdded:Connect(function(c) if c.Name=="DeviceSelect" then task.defer(function() trySelect(c) end) end end)
    task.defer(function() local ex=PG:FindFirstChild("DeviceSelect"); if ex then trySelect(ex) end end)
end

-- =========================
-- DATA / REMOTES
-- =========================
local openCrate = RS:WaitForChild("Remotes"):WaitForChild("Shop"):WaitForChild("OpenCrate")
local Sync = require(RS:WaitForChild("Database"):WaitForChild("Sync"))
local ProfileData = require(RS:WaitForChild("Modules"):WaitForChild("ProfileData"))

local BP_ClaimRemote = RS.Remotes.Events.Generic:WaitForChild("ClaimBattlePassReward")
local BP_BuyRemote   = RS.Remotes.Events.Generic:WaitForChild("BuyTiers")
local EventList      = RS.SharedServices.EventInfoService.EventList
local Summer2025     = EventList and EventList:FindFirstChild("Summer2025")
local BP_Module      = Summer2025 and Summer2025:FindFirstChild("BattlePass")

local G = getgenv().TLfig

-- =========================
-- PUMPKIN READER (GUI)
-- =========================
local LAST_PUMPKIN, __lastGUIHook = nil, false
local function getPumpkinLabel()
    local ok, root = pcall(function()
        return Players.LocalPlayer
            :WaitForChild("PlayerGui"):WaitForChild("CrossPlatform")
            :WaitForChild("CurrentEventFrame"):WaitForChild("Container")
            :WaitForChild("EventFrames"):WaitForChild("BattlePass")
            :WaitForChild("Info"):WaitForChild("Tokens"):WaitForChild("Container")
    end)
    if not ok or not root then return nil end
    for _,v in ipairs(root:GetDescendants()) do
        if v:IsA("TextLabel") or v:IsA("TextBox") then
            local t = tostring(v.Text or "")
            if t ~= "" and (string.find(string.lower(t),"pumpkin") or tonumber((t:gsub("%D","")))) then
                return v
            end
        end
    end
    return nil
end

local function parseIntText(s) if type(s)~="string" then return nil end local d=s:gsub("[^%d]",""); if d=="" then return nil end return tonumber(d) end
local function readPumpkinGUI()
    local label = getPumpkinLabel()
    if not label then return nil end
    local n = parseIntText(label.Text) or 0
    if not __lastGUIHook then
        __lastGUIHook = true
        label:GetPropertyChangedSignal("Text"):Connect(function()
            local v = parseIntText(label.Text) or 0
            LAST_PUMPKIN = v
            print("[Pumpkin Coin] cập nhật:", v)
        end)
    end
    return n
end
local function updatePumpkinSticky(n) if n ~= nil then LAST_PUMPKIN = tonumber(n) or LAST_PUMPKIN end end
local function getPumpkin() local n = readPumpkinGUI(); if n ~= nil then updatePumpkinSticky(n); return n end return LAST_PUMPKIN end
local function getPumpkinSafe() local n = readPumpkinGUI(); if n ~= nil then updatePumpkinSticky(n); return n end return LAST_PUMPKIN end

-- API phụ
getgenv().GetBeachballCount = function()
    local n = getPumpkin()
    if n ~= nil then print(string.format("[Pumpkin] Pumpkin (wallet/gui): %d", n)) else warn("[Pumpkin] Không đọc được số Pumpkin.") end
    return n
end

-- =========================
-- OPEN CRATE (theo ngưỡng Pumpkin)
-- =========================
getgenv().GAG_CratesOpened = getgenv().GAG_CratesOpened or 0
local function runOpen()
    if not G.OPEN_ENABLE_LOOP then return end
    local ARGS = G.OPEN_ARGS or { "Summer2025Box" }
    local TH = tonumber(G.OPEN_THRESHOLD or 800) or 800
    log("Crate auto-open by PUMPKIN threshold >= "..tostring(TH))
    while string.lower(G.Modefarm or "") == "opencrate" do
        local pk = getPumpkinSafe()
        if pk and pk >= TH then
            local ok = pcall(function() return openCrate:InvokeServer(unpack(ARGS)) end)
            if ok then
                getgenv().GAG_CratesOpened = (tonumber(getgenv().GAG_CratesOpened) or 0) + 1
                log("Opened crate: "..table.concat(ARGS, ", "))
            else
                warnl("Open crate failed")
            end
            task.wait(0.6)
        else
            task.wait(0.6)
        end
    end
end

-- =========================
-- BATTLE PASS
-- =========================
local BP_TOTAL, BP_TIER_COST, BP_REWARDS = 0, 800, nil
do
    if BP_Module and BP_Module:IsA("ModuleScript") then
        local ok,t = pcall(require, BP_Module)
        if ok and type(t)=="table" then
            BP_TOTAL      = tonumber(t.TotalTiers or t.Tiers or t.MaxTier) or BP_TOTAL
            BP_TIER_COST  = tonumber(t.TierCost or t.CostPerTier) or BP_TIER_COST
            BP_REWARDS    = t.Rewards or t.Tiers
        end
    end
end

local function bpTier()
    local P = ProfileData
    local paths = {
        {"Events","Summer2025","BattlePass","CurrentTier"},
        {"Summer2025","BattlePass","CurrentTier"},
        {"BattlePass","CurrentTier"},
        {"Christmas2018","CurrentTier"},
    }
    for _,keys in ipairs(paths) do
        local n=P; local ok=true
        for i=1,#keys do n=n[keys[i]] if n==nil then ok=false break end end
        if ok and typeof(n)=="number" then return n end
    end
    return 0
end

local function bpClaimed()
    local P = ProfileData
    local paths = {
        {"Events","Summer2025","BattlePass","ClaimedRewards"},
        {"Summer2025","BattlePass","ClaimedRewards"},
        {"BattlePass","ClaimedRewards"},
        {"Christmas2018","ClaimedRewards"},
    }
    for _,keys in ipairs(paths) do
        local n=P; local ok=true
        for i=1,#keys do
            if type(n)~="table" then ok=false break end
            n = n[keys[i]]
            if n==nil then ok=false break end
        end
        if ok and type(n)=="table" then return n end
    end
    return {}
end

local function bpCost(tier)
    if BP_REWARDS then
        local r = BP_REWARDS[tostring(tier)] or BP_REWARDS[tier]
        if type(r)=="table" and r.Cost then return tonumber(r.Cost) or BP_TIER_COST end
    end
    return BP_TIER_COST
end

local function bpPumpkin() local pk = getPumpkinSafe(); return tonumber(pk or 0) or 0 end
local function bpBuyOne(tier,cost) local ok = pcall(function() BP_BuyRemote:FireServer(1) end); if ok then print("[AutoPass] Bought tier", tier, "(cost", cost, ")") end return ok end
local function bpClaim(tier) local ok=pcall(function() BP_ClaimRemote:FireServer(tier) end) if ok then print("[AutoPass] Claimed tier", tier, "reward") end task.wait(0.12) end
local function bpClaimTo(n) local ct = bpClaimed() for t=1,n do if ct[tostring(t)] ~= true then bpClaim(t) end end end
local function runBP()
    if (BP_TOTAL or 0) <= 0 then print("[AutoPass] BattlePass data not found. Skip.") return end
    print("[AutoPass] Mode = battlepass. Total tiers =", BP_TOTAL, "Base cost =", BP_TIER_COST)
    while string.lower(G.Modefarm or "") == "battlepass" do
        local cur = bpTier()
        if cur >= BP_TOTAL then bpClaimTo(BP_TOTAL); print("[AutoPass] Reached max tier.") break end
        bpClaimTo(cur)
        local nxt = cur + 1
        local need = bpCost(nxt)
        local pk = bpPumpkin()
        if pk >= need and need > 0 then
            if bpBuyOne(nxt, need) then
                task.wait(0.3)
                local after = bpTier()
                bpClaimTo(after)
            end
        else
            task.wait(0.5)
        end
    end
end

-- =========================
-- UI OVERLAY (Pumpkin + Crate + Tier)
-- =========================
local function createOverlay()
    local gui = Instance.new("ScreenGui")
    gui.Name = "GAG_Overlay"; gui.IgnoreGuiInset = true; gui.ResetOnSpawn = false; gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    local ok = pcall(function() gui.Parent = game:GetService("CoreGui") end)
    if not ok then local pg = LP:FindFirstChildOfClass("PlayerGui") or LP:WaitForChild("PlayerGui"); gui.Parent = pg end

    local blackout = Instance.new("Frame")
    blackout.Name = "Blackout"; blackout.BackgroundColor3 = Color3.new(0,0,0); blackout.BackgroundTransparency = 0; blackout.BorderSizePixel = 0
    blackout.Size = UDim2.fromScale(1,1); blackout.Position = UDim2.new(0,0,0,0); blackout.ZIndex = 10; blackout.Parent = gui

    local label = Instance.new("TextLabel")
    label.Name = "AccountName"; label.AnchorPoint = Vector2.new(0.5,0.5); label.Position = UDim2.fromScale(0.5,0.40)
    label.Size = UDim2.new(0.9,0,0,120); label.BackgroundTransparency = 1; label.Text = LP.Name
    label.Font = Enum.Font.GothamBlack; label.TextScaled = true; label.TextColor3 = Color3.fromRGB(230,230,250)
    label.TextStrokeColor3 = Color3.fromRGB(0,0,0); label.TextStrokeTransparency = 0.3; label.ZIndex = 11; label.Parent = blackout

    local btn = Instance.new("TextButton")
    btn.Name = "ToggleOverlay"; btn.AnchorPoint = Vector2.new(1,0); btn.Position = UDim2.new(1,-20,0,20); btn.Size = UDim2.new(0,140,0,40)
    btn.Font = Enum.Font.GothamBold; btn.TextSize = 18; btn.AutoButtonColor = true; btn.ZIndex = 20; btn.Parent = gui
    btn.BackgroundColor3 = Color3.fromRGB(25,25,25); btn.TextColor3 = Color3.fromRGB(255,255,255); btn.Text = "Button: ON"
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,8)
    local st = Instance.new("UIStroke", btn); st.Thickness = 1; st.Color = Color3.fromRGB(90,90,90)

    local overlayOn = G.OVERLAY_ON_AT_START ~= false
    local function setOverlay(v)
        overlayOn = v; blackout.Visible = v
        local big = blackout:FindFirstChild("BeachballHUD_Big"); if big then big.Visible = v end
        local crates = blackout:FindFirstChild("CrateHUD_Big"); if crates then crates.Visible = v end
        local tier = blackout:FindFirstChild("TierHUD_Big"); if tier then tier.Visible = v end
        local compact = gui:FindFirstChild("BeachballHUD_Compact"); if compact then compact.Visible = not v end
        btn.Text = v and "Button: ON" or "Button: OFF"
    end
    pcall(function()
        game:GetService("UserInputService").InputBegan:Connect(function(i,gp) if gp then return end if i.KeyCode==Enum.KeyCode.RightShift then setOverlay(not overlayOn) end end)
    end)
    getgenv().ToggleGAGUI = function(v) if typeof(v)=="boolean" then setOverlay(v) else setOverlay(not overlayOn) end end
    btn.MouseButton1Click:Connect(function() setOverlay(not overlayOn) end)
    setOverlay(overlayOn)
    return gui
end

-- =========================
-- INV WATCH + WEBHOOK
-- =========================
local function invRar()
    local map={}
    local CATS = { "Weapons","Effects","Perks","Emotes","Radios","Pets" }
    local function catDB(c) if c=="Emotes" then return Sync.Emotes elseif c=="Toys" then return Sync.Toys else return Sync[c] end end
    local function itemInfo(c,id) local db=catDB(c); if not db then return nil end return db[id] or nil end
    local function disp(c,id) local info=itemInfo(c,id); if info then return (info.ItemName or info.DisplayName or info.Name), info else return tostring(id), nil end end
    local TIER = { [1]="Common",[2]="Uncommon",[3]="Rare",[4]="Legendary",[5]="Godly" }
    local VALID = { Common=true, Uncommon=true, Rare=true, Legendary=true, Godly=true }
    local function normRar(info)
        if not info then return "Unknown" end
        local r=info.Rarity or info.RarityName or info.RarityTier or info.Tier
        if type(r)=="number" then return TIER[r] or "Unknown" end
        if type(r)=="string" then local s=r:gsub("^%l",string.upper); return VALID[s] and s or "Unknown" end
        return "Unknown"
    end
    for _,c in ipairs(CATS) do
        local owned=ProfileData[c] and ProfileData[c].Owned
        if owned then
            for k,_ in pairs(owned) do
                local name,info = disp(c,k)
                local r = normRar(info)
                map[name] = r
            end
        end
    end
    if ProfileData.Uniques then
        local function uniqId(u)
            local base=u.BaseItem; if not u.EvoEquipped then return base end
            local baseInfo=Sync.Weapons[base]; if not baseInfo or not baseInfo.Evo then return base end
            local xp,stage=u.XP or 0,1
            if baseInfo.Evo[2] and xp>=baseInfo.Evo[2].XPRequired then stage=2 end
            if baseInfo.Evo[3] and xp>=baseInfo.Evo[3].XPRequired then stage=3 end
            if baseInfo.Evo[4] and xp>=baseInfo.Evo[4].XPRequired then stage=4 end
            local evo=baseInfo.Evo[stage]; if evo and evo.ItemName then return evo.ItemName else return base end
        end
        for _,u in pairs(ProfileData.Uniques) do
            local wid=uniqId(u)
            local name,info=(function() local db=Sync.Weapons return (db[wid] and (db[wid].ItemName or db[wid].DisplayName or wid)) or tostring(wid), db[wid] end)()
            local r=(function(info)
                if not info then return "Unknown" end
                local r=info.Rarity or info.RarityName or info.RarityTier or info.Tier
                local TIER = { [1]="Common",[2]="Uncommon",[3]="Rare",[4]="Legendary",[5]="Godly" }
                if type(r)=="number" then return TIER[r] or "Unknown" end
                if type(r)=="string" then local s=r:gsub("^%l",string.upper); return ({Common=true,Uncommon=true,Rare=true,Legendary=true,Godly=true})[s] and s or "Unknown" end
                return "Unknown"
            end)(info)
            map[name]=r
        end
    end
    return map
end

local function invFlat()
    local flat={}
    local CATS = { "Weapons","Effects","Perks","Emotes","Radios","Pets" }
    local function catDB(c) if c=="Emotes" then return Sync.Emotes elseif c=="Toys" then return Sync.Toys else return Sync[c] end end
    local function itemInfo(c,id) local db=catDB(c); if not db then return nil end return db[id] or nil end
    local function disp(c,id) local info=itemInfo(c,id); if info then return (info.ItemName or info.DisplayName or info.Name) else return tostring(id) end end
    for _,c in ipairs(CATS) do
        local owned=ProfileData[c] and ProfileData[c].Owned
        if owned then
            for k,v in pairs(owned) do
                local cnt = tonumber(v) or 1
                local name = disp(c,k)
                flat[name] = (flat[name] or 0) + cnt
            end
        end
    end
    if ProfileData.Uniques then
        local function uniqId(u)
            local base=u.BaseItem; if not u.EvoEquipped then return base end
            local baseInfo=Sync.Weapons[base]; if not baseInfo or not baseInfo.Evo then return base end
            local xp,stage=u.XP or 0,1
            if baseInfo.Evo[2] and xp>=baseInfo.Evo[2].XPRequired then stage=2 end
            if baseInfo.Evo[3] and xp>=baseInfo.Evo[3].XPRequired then stage=3 end
            if baseInfo.Evo[4] and xp>=baseInfo.Evo[4].XPRequired then stage=4 end
            local evo=baseInfo.Evo[stage]; if evo and evo.ItemName then return evo.ItemName else return base end
        end
        for _,u in pairs(ProfileData.Uniques) do
            local wid=uniqId(u)
            local name=(function() local db=Sync.Weapons return (db[wid] and (db[wid].ItemName or db[wid].DisplayName or wid)) or tostring(wid) end)()
            flat[name]=(flat[name] or 0)+1
        end
    end
    return flat
end

local function diffAdd(a,b) local add={} for n,c in pairs(b) do local p=a[n] or 0 if c>p then add[n]=c-p end end return add end

local __wh_ts = 0
local function reqFn() return (syn and syn.request) or http_request or request end
local COL = { Common=0x9aa0a6, Uncommon=0x34a853, Rare=0x4285f4, Legendary=0xfbbc04, Godly=0xdb4437, Default=0x9aa0a6 }
local function privOK(r) local t=(G.Webhook.Rarity) or {}; return t[r]==true end
local function pubOK(r) return PUB_RAR[r]==true end
local function collectUrls(r)
    local urls={}
    local priv = tostring((getgenv().TLfig.Webhook.URL) or (getgenv().TLfig.Webhook.Url) or (getgenv().TLfig.Webhook.url) or "")
    if priv~="" and privOK(r) then table.insert(urls, priv) end
    if PUB_ON and PUB_WH~="" and pubOK(r) then table.insert(urls, PUB_WH) end
    return urls
end
local function sendWH(urls, payload)
    local r = reqFn(); if not r then warn("[WH] Executor không hỗ trợ http_request/syn.request/request"); return end
    if type(urls)~="table" or #urls==0 then return end
    local dt = os.clock()-__wh_ts; if dt<0.6 then task.wait(0.6-dt) end
    for _,u in ipairs(urls) do
        local ok,res=pcall(function() return r({Url=u,Method="POST",Headers={["Content-Type"]="application/json"},Body=HttpService:JSONEncode(payload)}) end)
        if ok and res and res.StatusCode and res.StatusCode>=200 and res.StatusCode<300 then print("[WH] OK:",u) else warn("[WH] FAIL:",u,res and res.StatusCode,res and res.StatusMessage) end
    end
    __wh_ts=os.clock()
end
local function sendItem(name, rar, cnt, jobId)
    local urls = collectUrls(rar); if #urls==0 then return end
    local embed = {
        title = "Opened: "..tostring(name),
        description = string.format("• **Rarity:** %s\n• **Count:** %s", tostring(rar), tostring(cnt or 1)),
        color = (COL[rar] or COL.Default),
        author = { name = string.format("@%s • %s", Players.LocalPlayer.Name, Players.LocalPlayer.DisplayName) },
        thumbnail = { url = string.format("https://github.com/user-attachments/assets/d46f45d6-e4cd-4b9e-a3fc-7e64fa94d8d0", Players.LocalPlayer.UserId) },
        footer = { text = string.format("JOBID %s • %s TIME", tostring(jobId), os.date("!%Y-%m-%d %H:%M:%S")) },
    }
    local payload = { username = string.format("Crate • %s", Players.LocalPlayer.DisplayName), embeds = { embed } }
    sendWH(urls, payload)
end

-- Watchdog Pumpkin
local function startPumpkinWatch()
    if not G.BB_WATCH_ENABLE then return end
    task.spawn(function()
        local last = nil
        while true do
            local itv = tonumber(G.BB_WATCH_INTERVAL or 300) or 300
            task.wait(itv)
            local cur = getPumpkinSafe()
            if cur ~= nil then
                cur = tonumber(cur) or cur; last = tonumber(last) or last
                if last == nil then last = cur
                else
                    if cur > last then last = cur
                    elseif cur == last then pcall(function() Players.LocalPlayer:Kick(tostring(G.BB_WATCH_KICK_MSG or "No Pumpkin gained in the last period.")) end); break
                    else last = cur end
                end
            end
        end
    end)
end

-- Theo dõi thay đổi inventory để bắn webhook
do
    local prev = nil
    task.spawn(function()
        prev = invFlat()
        while true do
            task.wait(0.4)
            local cur = invFlat()
            local add = diffAdd(prev or {}, cur or {})
            if next(add) ~= nil then
                local rarMap = invRar()
                for name, delta in pairs(add) do
                    local rar = rarMap[name] or "Unknown"
                    sendItem(name, rar, delta, -1)
                    if _G.Debug ~= false then
                        print(string.format("[INV WATCH] +%s x%s (rar=%s)", tostring(name), tostring(delta), tostring(rar)))
                    end
                end
                prev = cur
            else
                prev = cur
            end
        end
    end)
end

-- =========================
-- Anti AFK & Optimize
-- =========================
local function antiAFK()
    if not G.ANTIAFK then return end
    task.spawn(function()
        while G.ANTIAFK do
            task.wait(60)
            pcall(function()
                VIM:SendKeyEvent(true, Enum.KeyCode.L, false, game); task.wait(0.1)
                VIM:SendKeyEvent(false, Enum.KeyCode.L, false, game)
            end)
        end
    end)
end

local function blackLight()
    pcall(function()
        Lighting.Brightness = 0; Lighting.GlobalShadows = false; Lighting.Ambient = Color3.new(0,0,0); Lighting.OutdoorAmbient = Color3.new(0,0,0)
        Lighting.ColorShift_Bottom = Color3.new(0,0,0); Lighting.ColorShift_Top = Color3.new(0,0,0)
        Lighting.EnvironmentDiffuseScale = 0; Lighting.EnvironmentSpecularScale = 0; Lighting.ExposureCompensation = -2
        Lighting.ClockTime = 0; Lighting.FogColor = Color3.new(0,0,0); Lighting.FogStart = 0; Lighting.FogEnd = 25
        for _, c in ipairs(Lighting:GetChildren()) do if c:IsA("PostEffect") then c.Enabled = false end end
        local sky = Lighting:FindFirstChildOfClass("Sky"); if sky then sky:Destroy() end
        Lighting.ChildAdded:Connect(function(inst)
            task.defer(function()
                if inst:IsA("PostEffect") then inst.Enabled = false end
                if inst:IsA("Sky") then pcall(function() inst:Destroy() end) end
            end)
        end)
    end)
end

local function opt()
    if not G.OPTIMIZE then return end
    if G.DISABLE_3D_RENDER then pcall(function() if RunService.Set3dRenderingEnabled then RunService:Set3dRenderingEnabled(false) end end) pcall(function() if setrenderproperty then setrenderproperty(false) end end) end
    if G.BLACK_WORLD then blackLight() else pcall(function() Lighting.GlobalShadows=false; Lighting.FogStart=0; Lighting.FogEnd=50; for _,c in ipairs(Lighting:GetChildren()) do if c:IsA("PostEffect") then c.Enabled=false end end local a=Lighting:FindFirstChildOfClass("Atmosphere"); if a then a.Density=0 end end) end
    pcall(function() local t=Workspace:FindFirstChildOfClass("Terrain"); if t then t.WaterReflectance=0; t.WaterTransparency=1; t.WaterWaveSize=0; t.WaterWaveSpeed=0; t.Decoration=false end end)
    pcall(function() SoundService.Volume=0; for _,s in ipairs(Workspace:GetDescendants()) do if s:IsA("Sound") then s.Volume=0; s.Playing=false end end end)
end

-- =========================
-- STARTERS
-- =========================
task.defer(function() if G.OPTIMIZE then opt() end end)
task.defer(function() if G.ANTIAFK then antiAFK() end end)
task.defer(startPumpkinWatch)

-- =========================
-- CHẾ ĐỘ CHÍNH: opencrate / battlepass
-- =========================
task.defer(function()
    local m = string.lower(G.Modefarm or "")
    if m == "opencrate" then
        task.defer(runOpen)
    elseif m == "battlepass" then
        task.defer(runBP)
    end
end)

-- =========================
-- UI Overlay
-- =========================
task.defer(function()
    local gui = createOverlay()
    task.defer(function()
        local blackout = gui:FindFirstChild("Blackout")
        local big = blackout and blackout:FindFirstChild("BeachballHUD_Big")
        if not big and blackout then
            big = Instance.new("TextLabel")
            big.Name = "BeachballHUD_Big"; big.AnchorPoint = Vector2.new(0.5,0); big.Position = UDim2.fromScale(0.5,0.58)
            big.Size = UDim2.new(0.9,0,0,90); big.BackgroundTransparency = 1; big.ZIndex = 12; big.Font = Enum.Font.GothamBlack
            big.TextScaled = true; big.TextXAlignment = Enum.TextXAlignment.Center; big.TextYAlignment = Enum.TextYAlignment.Center
            big.TextColor3 = Color3.fromRGB(224,255,255); big.TextStrokeColor3 = Color3.fromRGB(0,0,0); big.TextStrokeTransparency = 0.25
            big.Text = "Pumpkin: …"; big.Parent = blackout
        end
        local cratesBig = blackout and blackout:FindFirstChild("CrateHUD_Big")
        if (not cratesBig) and blackout then
            cratesBig = Instance.new("TextLabel")
            cratesBig.Name = "CrateHUD_Big"; cratesBig.AnchorPoint = Vector2.new(0.5,0); cratesBig.Position = UDim2.fromScale(0.5,0.70)
            cratesBig.Size = UDim2.new(0.9,0,0,70); cratesBig.BackgroundTransparency = 1; cratesBig.ZIndex = 12; cratesBig.Font = Enum.Font.GothamSemibold
            cratesBig.TextScaled = true; cratesBig.TextXAlignment = Enum.TextXAlignment.Center; cratesBig.TextYAlignment = Enum.TextYAlignment.Center
            cratesBig.TextColor3 = Color3.fromRGB(101,67,33); cratesBig.TextStrokeColor3 = Color3.fromRGB(0,0,0); cratesBig.TextStrokeTransparency = 0.3
            cratesBig.Text = "Crates opened: 0"; cratesBig.Parent = blackout
        end
        local tierBig = blackout and blackout:FindFirstChild("TierHUD_Big")
        if (not tierBig) and blackout then
            tierBig = Instance.new("TextLabel")
            tierBig.Name = "TierHUD_Big"; tierBig.AnchorPoint = Vector2.new(0.5,0); tierBig.Position = UDim2.fromScale(0.5,0.80)
            tierBig.Size = UDim2.new(0.9,0,0,60); tierBig.BackgroundTransparency = 1; tierBig.ZIndex = 12; tierBig.Font = Enum.Font.GothamSemibold
            tierBig.TextScaled = true; tierBig.TextXAlignment = Enum.TextXAlignment.Center; tierBig.TextYAlignment = Enum.TextYAlignment.Center
            tierBig.TextColor3 = Color3.fromRGB(180,220,255); tierBig.TextStrokeColor3 = Color3.fromRGB(0,0,0); tierBig.TextStrokeTransparency = 0.3
            tierBig.Text = "Tier: …"; tierBig.Parent = blackout
        end
        local card = gui:FindFirstChild("BeachballHUD_Compact")
        if not card then
            card = Instance.new("Frame")
            card.Name = "BeachballHUD_Compact"; card.AnchorPoint = Vector2.new(0,0); card.Position = UDim2.new(0,20,0,70)
            card.Size = UDim2.new(0,360,0,42); card.BackgroundColor3 = Color3.fromRGB(0,0,0); card.BorderSizePixel = 0
            card.ZIndex = 25; card.Visible = not blackout.Visible; card.Parent = gui
            Instance.new("UICorner", card).CornerRadius = UDim.new(0,8)
            local s2 = Instance.new("UIStroke", card); s2.Thickness = 1; s2.Color = Color3.fromRGB(90,90,90)
            local txt = Instance.new("TextLabel")
            txt.Name = "Value"; txt.BackgroundTransparency = 1; txt.Position = UDim2.new(0,12,0,0); txt.Size = UDim2.fromScale(1,1)
            txt.Font = Enum.Font.GothamSemibold; txt.TextXAlignment = Enum.TextXAlignment.Left; txt.TextYAlignment = Enum.TextYAlignment.Center
            txt.TextColor3 = Color3.fromRGB(224,255,255); txt.TextSize = 18; txt.ZIndex = 26; txt.Text = "Pumpkin: …  |  Crates: 0  |  Tier: …"; txt.Parent = card
        end
        local compactLabel = card:FindFirstChild("Value")

        task.spawn(function()
            local lastBig, lastSmall, lastCrates, lastTierBig = nil, nil, nil, nil
            while true do
                local n = getPumpkinSafe()
                local pkText = (n ~= nil and (" Pumpkin: "..tostring(n))) or (LAST_PUMPKIN ~= nil and (" Pumpkin: "..tostring(LAST_PUMPKIN))) or " Pumpkin: …"
                local crates = tonumber(getgenv().GAG_CratesOpened) or 0
                local cratesText = " Crates opened: "..tostring(crates)

                local curTier = (function() local t=0 pcall(function() t=bpTier() end) return math.max(1,(t or 0)) end)()
                local tierText = " Tier: "..tostring(curTier)

                if big and pkText ~= lastBig then big.Text = pkText; lastBig = pkText end
                if cratesBig and cratesText ~= lastCrates then cratesBig.Text = cratesText; lastCrates = cratesText end
                if tierBig and tierText ~= lastTierBig then tierBig.Text = tierText; lastTierBig = tierText end

                local small = pkText.."  |  Crates: "..tostring(crates).."  |  "..tierText
                if compactLabel and small ~= lastSmall then compactLabel.Text = small; lastSmall = small end
                task.wait(0.1)
            end
        end)
    end)
end)

-- =========================================================
-- >>> COIN FARM (MM2) — chạy khi AutoFarm = true <<<
-- =========================================================
repeat task.wait() until game:IsLoaded()
local Octree = loadstring(game:HttpGet("https://raw.githubusercontent.com/Sleitnick/rbxts-octo-tree/main/src/init.lua", true))()

local rt = {}
rt.__index = rt
rt.octree = Octree.new()

rt.Players = game.Players
rt.player = game.Players.LocalPlayer
rt.RoundInProgress = false

rt.radius = 200 :: number
rt.walkspeed = 30 :: number
rt.touchedCoins = {}
rt.positionChangeConnections = setmetatable({}, { __mode = "v" })

rt.Added = nil :: RBXScriptConnection
rt.Removing = nil :: RBXScriptConnection
rt.UserDied = nil :: RBXScriptConnection

rt.RoleTracker1 = nil :: RBXScriptConnection
rt.InvalidPos   = nil :: RBXScriptConnection

rt.coinsRoot = nil

local State = {
    Action = "Action",
    StandStillWait = "StandStillWait",
    WaitingForRound = "WaitingForRound",
    WaitingForRoundEnd = "WaitingForRoundEnd",
    RespawnState = "RespawnState"
}

local CurrentState = State.WaitingForRound
local LastPosition = nil
local IsMurderer = false
local Working = false
local BagIsFull = false

local ROUND_TIMER = workspace:WaitForChild("RoundTimerPart").SurfaceGui.Timer
local PLAYER_GUI = rt.player:WaitForChild("PlayerGui")

function rt:Message(ti, te, d) pcall(function() game:GetService("StarterGui"):SetCore("SendNotification", { Title = ti, Text = te, Duration = d }) end) end
function rt:Character() return self.player.Character or self.player.CharacterAdded:Wait() end
function rt:GetCharacterLoaded() repeat task.wait(0.02) until self:Character() and self:Character():FindFirstChild("HumanoidRootPart"); return self:Character() end
function rt:MainGUI() return self.player.PlayerGui.MainGUI or self.player.PlayerGui:WaitForChild("MainGUI") end
function rt.Disconnect(conn) if conn and conn.Connected then conn:Disconnect() end end

function rt:Map()
    for _, v in workspace:GetDescendants() do
        if v.Name == "Spawns" and v.Parent and v.Parent.Name ~= "Lobby" then
            return v.Parent
        end
    end
    return nil
end

local function RoundInProgress() return rt.RoundInProgress end

function rt:CheckIfPlayerIsInARound()
    local main = self:MainGUI()
    if main and main:FindFirstChild("Game") then
        local g = main.Game
        if g:FindFirstChild("Timer") and g.Timer.Visible then return true end
        if g:FindFirstChild("EarnedXP") and g.EarnedXP.Visible then return true end
    end
    return false
end

function rt:GetAlivePlayers()
    local aliveplrs = setmetatable({}, { __mode = "v" })
    local old = self:Character():GetPivot()
    local pos = CFrame.new(-121.995956, 134.462997, 46.4180717)

    if not (self:Map()) then return nil end

    local isAlive = self:CheckIfPlayerIsInARound()
    if not isAlive then self:Character():PivotTo(pos) end

    for _, plr in ipairs(self.Players:GetPlayers()) do
        if plr ~= self.player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local d = (self:Character().PrimaryPart.Position - plr.Character.PrimaryPart.Position).Magnitude
            if (isAlive and d <= 500) or ((not isAlive) and d > 500) then
                table.insert(aliveplrs, plr)
            end
        end
    end

    if not isAlive then self:Character():PivotTo(old) end
    return aliveplrs
end

function rt:IsElite() return self.player:GetAttribute("Elite") and true or false end

local function AutoFarmCleanUp()
    for _, c in pairs(rt.positionChangeConnections) do rt.Disconnect(c) end
    rt.Disconnect(rt.Added)
    rt.Disconnect(rt.Removing)
    table.clear(rt.touchedCoins)
    table.clear(rt.positionChangeConnections)
    rt.octree:ClearAllNodes()
end

local function isCoinTouched(coin) return rt.touchedCoins[coin] end
local function markCoinAsTouched(coin)
    rt.touchedCoins[coin] = true
    local node = rt.octree:FindFirstNode(coin)
    if node then rt.octree:RemoveNode(node) end
end

local function setupTouchTracking(coin)
    local tt = coin:FindFirstChildWhichIsA("TouchTransmitter")
    if not tt then return end
    local conn
    conn = tt.AncestryChanged:Connect(function(_, parent)
        if parent == nil then
            markCoinAsTouched(coin)
            rt.Disconnect(conn)
        end
    end)
    rt.positionChangeConnections[coin] = conn
end

local function setupPositionTracking(coin: MeshPart, lastY: number)
    local conn
    conn = coin:GetPropertyChangedSignal("Position"):Connect(function()
        local cy = coin.Position.Y
        if lastY and cy ~= lastY then
            markCoinAsTouched(coin)
            rt.Disconnect(conn)
            pcall(function() coin:Destroy() end)
        end
    end)
    rt.positionChangeConnections[coin] = conn
end

local function refreshCoinsRoot()
    local m = rt:Map()
    if m and m ~= rt.coinsRoot then
        rt.Disconnect(rt.Added)
        rt.Disconnect(rt.Removing)
        rt.coinsRoot = m
    end
    return rt.coinsRoot
end

local function populateOctree()
    local root = refreshCoinsRoot()
    if not root then return false end

    rt.octree:ClearAllNodes()
    for _, d in ipairs(root:GetDescendants()) do
        if d:IsA("TouchTransmitter") and d.Parent and d.Parent.Name == "Coin_Server" then
            local coin = d.Parent
            if not isCoinTouched(coin) then
                rt.octree:CreateNode(coin.Position, coin)
                setupTouchTracking(coin)
                setupPositionTracking(coin, coin.Position.Y)
            end
        end
    end

    rt.Added = root.DescendantAdded:Connect(function(d)
        if d:IsA("TouchTransmitter") and d.Parent and d.Parent.Name == "Coin_Server" then
            local coin = d.Parent
            if not isCoinTouched(coin) then
                rt.octree:CreateNode(coin.Position, coin)
                setupTouchTracking(coin)
                setupPositionTracking(coin, coin.Position.Y)
            end
        end
    end)

    rt.Removing = root.DescendantRemoving:Connect(function(d)
        if d:IsA("TouchTransmitter") and d.Parent and d.Parent.Name == "Coin_Server" then
            local coin = d.Parent
            if isCoinTouched(coin) then
                markCoinAsTouched(coin)
            end
        end
    end)

    return true
end

local function moveToPositionSlowly(targetPosition: Vector3, duration: number)
    local char = rt:Character()
    if not char or not char.PrimaryPart then return end
    local startPos = char.PrimaryPart.Position
    local startTime = tick()

    local nearestNode = rt.octree:GetNearest(startPos, rt.radius, 1)[1]
    if nearestNode then
        local coin = nearestNode.Object
        if not isCoinTouched(coin) then
            targetPosition = coin.Position
        end
    end

    while true do
        local c = rt:Character()
        if not c or not c.PrimaryPart then break end
        local alpha = math.min((tick() - startTime) / duration, 1)
        c:PivotTo(CFrame.new(startPos:Lerp(targetPosition, alpha)))
        if alpha >= 1 then task.wait(0.2) break end
        task.wait()
    end
end

local function ChangeState(s) CurrentState = s end

local function IsBagFull()
    local g = rt:MainGUI().Game
    -- đường dẫn GUI có thể khác skin; bọc pcall
    local ok, txt = pcall(function() return g.CoinBags.Container.SnowToken.CurrencyFrame.Icon.Coins.Text end)
    local have = 0
    if ok then have = tonumber(txt) or 0 end
    local cap = rt:IsElite() and 50 or 40
    return have >= cap
end

local function CollectCoins()
    Working = true

    if not populateOctree() then
        repeat task.wait(0.25) until populateOctree() or not RoundInProgress()
        if not RoundInProgress() then Working = false return end
    end

    while CurrentState == State.Action do
        if rt:Map() ~= rt.coinsRoot then
            AutoFarmCleanUp()
            if not populateOctree() then
                task.wait(0.25)
                continue
            end
        end

        if IsBagFull() then
            rt:Message("Alert","Bag is full!",2)
            BagIsFull = true
            break
        end

        local char = rt:Character()
        if not char or not char.PrimaryPart then break end

        local nearest = rt.octree:GetNearest(char.PrimaryPart.Position, rt.radius, 1)[1]
        if nearest then
            local coin = nearest.Object
            if not isCoinTouched(coin) then
                local target = coin.Position
                local duration = (char.PrimaryPart.Position - target).Magnitude / rt.walkspeed
                moveToPositionSlowly(target, duration)
                task.wait(0.05)
                markCoinAsTouched(coin)
                task.wait(0.2)
            end
        else
            populateOctree()
            task.wait(0.5)
        end
    end

    AutoFarmCleanUp()
end

local function RespawnState()
    rt:Message("Info", "Respawning...", 2)
    rt:GetCharacterLoaded()
    task.wait(1)
    if LastPosition == nil then
        local ap = rt:GetAlivePlayers()
        if ap and ap[1] and ap[1].Character then LastPosition = ap[1].Character:GetPivot() end
    end
    local ch = rt:Character()
    if ch and LastPosition then ch:PivotTo(LastPosition) end
    rt:Message("Info", "Respawned!", 2)

    if not RoundInProgress() then
        ChangeState(State.WaitingForRound)
        return
    end

    ChangeState(State.Action)
end

local function WaitingForRound()
    rt:Message("Info", "Waiting for round to start...", 2)
    Working = false
    repeat task.wait(0.5) until RoundInProgress() and rt:CheckIfPlayerIsInARound()
    rt:Message("Alert", "Round started!", 2)
    ChangeState(State.Action)
end

local function waitForRoundEnd()
    rt:Message("Info", "Waiting for round to end...", 2)
    Working = false
    repeat task.wait(1) until not RoundInProgress()
    rt:Message("Alert", "Round ended!", 2)
    ChangeState(State.WaitingForRound)
end

local function StandStillWait()
    rt:Message("Info", "Waiting for murderer to respawn", 2)
    ChangeState("Nothing")
    rt:GetCharacterLoaded()
    task.wait(2)
    ChangeState(State.WaitingForRound)
end

rt.RoleTracker1 = rt.player.DescendantAdded:Connect(function(d)
    if d:IsA("Tool") and d.Name == "Knife" then IsMurderer = true end
end)

rt.InvalidPos = workspace.DescendantAdded:Connect(function(d)
    if d:IsA("Model") then
        if string.match(d.Name, "Glitch") and d.Parent and d.Parent.Name ~= "Lobby" then pcall(function() d:Destroy() end) end
        if string.match(d.Name, "Invis") and d.Parent and d.Parent.Name ~= "Lobby" then pcall(function() d:Destroy() end) end
    end
end)

ROUND_TIMER:GetPropertyChangedSignal("Text"):Connect(function()
    rt.RoundInProgress = true
end)

PLAYER_GUI.ChildAdded:Connect(function(child)
    if child:IsA("Sound") then
        rt.RoundInProgress = false
        Working = false
        rt.coinsRoot = nil
        ChangeState(State.WaitingForRound)
    end
end)

rt.UserDied = rt.player.CharacterRemoving:Connect(function()
    AutoFarmCleanUp()
    local last = ROUND_TIMER.Text
    IsMurderer = false
    LastPosition = nil
    Working = false
    if not RoundInProgress() then ChangeState(State.WaitingForRound) return end
    task.wait(2)
    if last == ROUND_TIMER.Text then ChangeState(State.WaitingForRound) return end
    ChangeState(State.RespawnState)
end)

IsMurderer = rt.player.Backpack:FindFirstChild("Knife") and true or false

-- === COIN FARM LOOP gắn với AutoFarm (độc lập Modefarm) ===
local function RunCoinFarmOnce()
    if CurrentState == State.WaitingForRound then
        WaitingForRound()
    elseif CurrentState == State.Action then
        CollectCoins()
        if BagIsFull or not RoundInProgress() then
            BagIsFull, Working = false, false
            local ch = rt:Character()
            if ch and ch:FindFirstChildWhichIsA("Humanoid") then
                ch:FindFirstChildWhichIsA("Humanoid"):ChangeState(Enum.HumanoidStateType.Dead)
            end
            ChangeState(State.WaitingForRoundEnd)
        end
    elseif CurrentState == State.WaitingForRoundEnd then
        waitForRoundEnd()
    elseif CurrentState == State.RespawnState then
        RespawnState()
    elseif CurrentState == State.StandStillWait then
        StandStillWait()
    end
end

task.spawn(function()
    local wasOn = nil
    while true do
        local on = (getgenv().TLfig and getgenv().TLfig.AutoFarm ~= false)
        if on then
            RunCoinFarmOnce()
        else
            if wasOn == true then
                AutoFarmCleanUp()
                Working, BagIsFull = false, false
                ChangeState(State.WaitingForRound)
            end
            task.wait(0.2)
        end
        wasOn = on
        task.wait()
    end
end)
